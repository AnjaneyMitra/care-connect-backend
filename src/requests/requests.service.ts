import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateRequestDto } from './dto/create-request.dto';
import { UsersService } from '../users/users.service';

@Injectable()
export class RequestsService {
    constructor(
        private prisma: PrismaService,
        private usersService: UsersService,
    ) { }

    async create(parentId: string, createRequestDto: CreateRequestDto) {
        // 1. Get parent profile for location
        const parent = await this.usersService.findOne(parentId);
        if (!parent || !parent.profiles || !parent.profiles.lat || !parent.profiles.lng) {
            throw new BadRequestException('Parent profile incomplete. Address and location required.');
        }

        // 2. Create the service request
        const request = await this.prisma.service_requests.create({
            data: {
                parent_id: parentId,
                date: new Date(createRequestDto.date),
                start_time: new Date(`1970-01-01T${createRequestDto.start_time}Z`), // Store as time on dummy date
                duration_hours: createRequestDto.duration_hours,
                num_children: createRequestDto.num_children,
                children_ages: createRequestDto.children_ages || [],
                special_requirements: createRequestDto.special_requirements,
                max_hourly_rate: createRequestDto.max_hourly_rate,
                location_lat: parent.profiles.lat,
                location_lng: parent.profiles.lng,
                status: 'pending',
            },
        });

        // 3. Trigger auto-matching
        await this.triggerMatching(request.id);

        return request;
    }

    async triggerMatching(requestId: string) {
        const request = await this.prisma.service_requests.findUnique({
            where: { id: requestId },
            include: { assignments: true } // Include previous assignments
        });

        if (!request) throw new NotFoundException('Request not found');

        // Get IDs of nannies already assigned (rejected or timeout)
        const excludedNannyIds = request.assignments.map(a => a.nanny_id);

        // Format excluded IDs for SQL NOT IN clause
        const excludedIdsSql = excludedNannyIds.length > 0
            ? `AND u.id NOT IN (${excludedNannyIds.map(id => `'${id}'`).join(',')})`
            : '';

        // Find nearby nannies
        // Using Haversine formula in raw SQL for efficiency
        const radiusKm = 10;

        // Note: Prisma raw query parameter substitution doesn't work well with dynamic IN clauses
        // so we handle the exclusion logic carefully or use Prisma.sql helper if available,
        // but for simplicity here we'll fetch more candidates and filter in memory if needed,
        // OR use the string interpolation for the ID list (be careful of injection if IDs weren't UUIDs).
        // Since IDs are UUIDs generated by system, it's relatively safe, but let's try to use pure Prisma if possible?
        // No, Haversine needs raw SQL.

        // Let's use a safer approach: Fetch candidates with raw SQL, then filter in JS

        const nannies = await this.prisma.$queryRawUnsafe(`
      SELECT u.id, 
             (6371 * acos(cos(radians(${request.location_lat})) * cos(radians(p.lat)) * cos(radians(p.lng) - radians(${request.location_lng})) + sin(radians(${request.location_lat})) * sin(radians(p.lat)))) AS distance
      FROM users u
      JOIN profiles p ON u.id = p.user_id
      JOIN nanny_details nd ON u.id = nd.user_id
      WHERE u.role = 'nanny'
      AND u.is_verified = true
      AND nd.is_available_now = true
      ${excludedIdsSql}
      AND (6371 * acos(cos(radians(${request.location_lat})) * cos(radians(p.lat)) * cos(radians(p.lng) - radians(${request.location_lng})) + sin(radians(${request.location_lat})) * sin(radians(p.lat)))) < ${radiusKm}
      ORDER BY distance ASC
      LIMIT 5;
    `) as any[];

        if (nannies.length > 0) {
            // Assign to the first match
            const bestMatch = nannies[0];

            // Create assignment
            const assignment = await this.prisma.assignments.create({
                data: {
                    request_id: requestId,
                    nanny_id: bestMatch.id,
                    response_deadline: new Date(Date.now() + 15 * 60 * 1000), // 15 minutes from now
                    status: 'pending',
                    rank_position: request.assignments.length + 1,
                },
            });

            // Update request status
            await this.prisma.service_requests.update({
                where: { id: requestId },
                data: {
                    status: 'assigned',
                    current_assignment_id: assignment.id
                },
            });

            console.log(`Assigned request ${requestId} to nanny ${bestMatch.id}`);

            return assignment;
        } else {
            console.log(`No nannies found for request ${requestId}`);
            // TODO: Notify parent no matches found
            return null;
        }
    }

    async findOne(id: string) {
        return this.prisma.service_requests.findUnique({
            where: { id },
            include: {
                users: {
                    include: { profiles: true }
                },
                assignments: {
                    include: { users: { include: { profiles: true } } }
                }
            }
        });
    }

    async findAllByParent(parentId: string) {
        return this.prisma.service_requests.findMany({
            where: { parent_id: parentId },
            orderBy: { created_at: 'desc' },
            include: {
                assignments: {
                    where: { status: 'pending' },
                    include: { users: { include: { profiles: true } } }
                }
            }
        });
    }
}
